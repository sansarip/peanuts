// Compiled by ClojureScript 1.10.866 {:optimizations :simple}
goog.provide('peanuts.compile');
goog.require('cljs.core');
goog.require('peanuts.macros');
goog.require('cljs.js');
/**
 * A bundle of dependencies.
 */
peanuts.compile.dependencies = cljs.core.PersistentHashMap.fromArrays(["peanuts.cards.ex-c228","peanuts.cards.ex-a226","peanuts.cards.ex-f82c","clojure.set","peanuts.cards.ex-aa95","clojure.walk","peanuts.cards.ex-b6a6","peanuts.cards.ex-dd80","peanuts.core","peanuts.cards.ex-c4d3","peanuts.cards.ex-e6c7"],["(ns peanuts.cards.ex-c228)\n\n(defn greeting []\n  (let [n @(re-frame.core/subscribe [:name])]\n    [:p (str \"Hello, \" n \"!\")]))\n\n[greeting]","(ns peanuts.cards.ex-a226\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc greeting [n]\n  [:p (str \"Hello, \" n \"!\")])\n\n[:div\n [greeting :name]\n [greeting [:name]]\n [greeting \"Garbonzo\"]]","(ns peanuts.cards.ex-f82c\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc greeting [n]\n  [:p (str \"Hello, \" n \"!\")])\n\n[:div\n ;; Here [:name] will retain its original value\n ;; You can also use the shorter :rl keyword instead of :redlist\n [greeting ^:redlist [:name]]]",";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)\n\n(defn- bubble-max-key [k coll]\n  \"Move a maximal element of coll according to fn k (which returns a number) \n   to the front of coll.\"\n  (let [max (apply max-key k coll)]\n    (cons max (remove #(identical? max %) coll))))\n\n(defn union\n  \"Return a set that is the union of the input sets\"\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn intersection\n  \"Return a set that is the intersection of the input sets\"\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))\n\n(defn difference\n  \"Return a set that is the first set without elements of the remaining sets\"\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))\n\n\n(defn select\n  \"Returns a set of the elements for which pred is true\"\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))\n\n(defn project\n  \"Returns a rel of the elements of xrel with only the keys in ks\"\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))\n\n(defn rename-keys\n  \"Returns the map with the keys in kmap renamed to the vals in kmap\"\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))\n\n(defn rename\n  \"Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap\"\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))\n\n(defn index\n  \"Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.\"\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))\n   \n(defn map-invert\n  \"Returns the map with the vals mapped to the keys.\"\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))\n\n(defn join\n  \"When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.\"\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))\n\n(defn subset? \n  \"Is set1 a subset of set2?\"\n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))\n\n(defn superset? \n  \"Is set1 a superset of set2?\"\n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))\n\n(comment\n(refer 'set)\n(def xs #{{:a 11 :b 1 :c 1 :d 4}\n         {:a 2 :b 12 :c 2 :d 6}\n         {:a 3 :b 3 :c 3 :d 8 :f 42}})\n\n(def ys #{{:a 11 :b 11 :c 11 :e 5}\n         {:a 12 :b 11 :c 12 :e 3}\n         {:a 3 :b 3 :c 3 :e 7 }})\n\n(join xs ys)\n(join xs (rename ys {:b :yb :c :yc}) {:a :a})\n\n(union #{:a :b :c} #{:c :d :e })\n(difference #{:a :b :c} #{:c :d :e})\n(intersection #{:a :b :c} #{:c :d :e})\n\n(index ys [:b]))\n\n","(ns peanuts.cards.ex-aa95\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc greeting [f-n l-n]\n  {:greenlist [l-n]}\n  [:p (str \"Hello, \" f-n \" \" l-n \"!\")])\n\n[:div\n ;; Only the second arg is a candidate for being subscribed with\n ;; The first arg will be used as is\n [greeting :earthling :name]\n [greeting :earthling [:name]]]\n",";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.cljs - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; Jul5 17, 2011\n\n;; CHANGE LOG:\n;;\n;; * July 17, 2011: Port to ClojureScript\n;; \n;; * December 15, 2008: replaced 'walk' with 'prewalk' & 'postwalk'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)\n\n(defn walk\n  \"Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form)\n    (outer (MapEntry. (inner (key form)) (inner (val form)) nil))\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))\n\n(defn postwalk\n  \"Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  \"Like postwalk, but does pre-order traversal.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n(defn keywordize-keys\n  \"Recursively transforms all map keys from strings to keywords.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  \"Recursively transforms all map keys from keywords to strings.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n","(ns peanuts.cards.ex-b6a6\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc greeting [n]\n  {:redlist [n]}\n  [:p (str \"Hello, \" n \"!\")])\n\n[:div\n ;; Here name won't be used as a subscription ID\n [greeting :name]\n [greeting [:name]]]\n","(ns peanuts.cards.ex-dd80\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc checkbox [selected?]\n  [:input {:type    :checkbox\n           :checked selected?}])\n\n[:div\n (for [id (range 5)]\n   ^{:key id}\n   [checkbox [:selected? id]])]","(ns peanuts.core\n  (:require\n    [clojure.walk :as walk]\n    [clojure.set :as cljset]))\n\n(defn- not-empty-coll [thing]\n  (if (coll? thing) (not-empty thing) thing))\n\n(defn- not-empty-vals [thing]\n  (cond\n    (map? thing) (some #(not-empty-coll (second %)) thing)\n    (coll? thing) (not-empty-coll thing)\n    thing thing\n    :else nil))\n\n(defn- binding-vector? [thing]\n  (and (vector? thing) (-> thing first symbol?)))\n\n(defn- remove-deep [key-set data]\n  (if (not-empty key-set)\n    (->> data\n         (walk/prewalk (fn [node]\n                         (cond\n                           (binding-vector? node) (vec (remove key-set node))\n                           (map? node) (apply dissoc (dissoc node :or) key-set)\n                           (get key-set node) nil\n                           :else node)))\n         (filterv not-empty-vals))\n    data))\n\n(defn- symbol-in? [key-set s]\n  (if (symbol? s)\n    (get key-set s)\n    s))\n\n(defn- filter-symbol-keys [key-set m]\n  (reduce-kv (fn [c k v]\n               (if (symbol-in? key-set k)\n                 (assoc c k v)\n                 c))\n             {}\n             m))\n\n(defn- filter-deep [key-set data]\n  (if (not-empty key-set)\n    (->> data\n         (walk/prewalk (fn [node]\n                         (cond\n                           (binding-vector? node) (filterv #(symbol-in? key-set %) node)\n                           (map? node) (filter-symbol-keys key-set (dissoc node :or))\n                           (not (symbol-in? key-set node)) nil\n                           :else node)))\n         (filterv not-empty-vals)\n         (remove #{'&}))\n    data))\n\n(defn get-associative-destructuring-vector [node]\n  (and (or (map? node) nil)\n       (select-keys node #{:keys :strs :syms})))\n\n(defn- flatten-maps [args]\n  (->> args\n       (walk/prewalk (fn [node]\n                       (let [assoc-dest-vec (get-associative-destructuring-vector node)]\n                         (cond\n                           (not-empty assoc-dest-vec) (vec (vals assoc-dest-vec))\n                           (map? node) (vec (keys node))\n                           :else node))))\n       flatten\n       distinct))\n\n(defn- subscribe-form [binding-vec default]\n  `(~'if-let [~'sub (~'re-frame.core/subscribe ~binding-vec)]\n     ~'(deref sub)\n     ~default))\n\n(def ^:private redlist-options [:exempt :redlist :rl :redlist1 :rl1])\n\n(defn rm-rl1-meta-form [binding]\n  `(~'vary-meta ~binding ~'dissoc :rl1 :redlist1))\n\n(defn- cond-form [binding binding-args]\n  (let [binding-vec (into [binding] binding-args)]\n    `(~'cond\n       (~'let [~'rl-opts (~'select-keys (~'meta ~binding) ~redlist-options)] ~'(some identity rl-opts)) ~(rm-rl1-meta-form binding)\n       (~'keyword? ~binding) ~(subscribe-form binding-vec binding)\n       (~'and (~'vector? ~binding) (~'keyword? (~'first ~binding))) ~(subscribe-form binding binding)\n       (~'or (~'-> ~binding ~'meta :sub-fn) (~'and (~'fn? ~binding) ~binding-args)) ~(seq binding-vec)\n       :else ~binding)))\n\n(defn- seq->let-form [args seq*]\n  (->> seq*\n       (reduce (fn [c b]\n                 (-> c\n                     (conj b)\n                     (conj (cond-form b (get args b)))))\n               [])\n       (conj '(let))\n       reverse))\n\n(defn- quote-symbols [coll]\n  (walk/postwalk (fn [v] (if (symbol? v) (list 'quote v) v)) coll))\n\n(defn- redlist-meta? [binding]\n  (let [{:keys [exempt redlist]} (meta binding)]\n    (or exempt redlist)))\n\n(defn- peanut\n  [n f {:keys [exempt greenlist redlist only def? sub-args] :as meta-map}]\n  (let [[_ args & body] f\n        bindings (->> args\n                      (remove-deep (cljset/union (set exempt) (set redlist)))\n                      vec\n                      (filter-deep (cljset/union (set only) (set greenlist)))\n                      flatten-maps\n                      (remove (some-fn #{'&} redlist-meta?))\n                      (seq->let-form sub-args))\n        symbol-quoted-meta-map (quote-symbols meta-map)]\n    (cond->> body\n             '->> (concat bindings)\n             '->> list\n             '->> (concat `(~'fn ~args))\n             def? list\n             def? (concat `(def ~(->> n\n                                      meta\n                                      (merge symbol-quoted-meta-map)\n                                      (with-meta n)))))))\n(defmacro fc\n  ([f opts]\n   (peanut nil f (merge opts {:def? false})))\n  ([f] `(fc ~f {})))\n\n(defmacro defc\n  ([n f opts]\n   (peanut n f (merge opts {:def? true})))\n  ([n f]\n   `(defc ~n ~f {})))\n\n(defn- merge-meta-maps [meta-map1 [meta-map2 :as _fnbody] & other-maps]\n  (cond-> (apply merge meta-map1 other-maps)\n          (map? meta-map2) (merge meta-map2)))\n\n(defmacro defnc\n  \"Takes similar arguments to defn and returns a similar result.\n   The returned function body will be wrapped in a let-block which will\n   conditionally rebind the function args to values of re-frame subscriptions.\"\n  [n & [doc-str meta-map & [args & body :as args&body]]]\n  (cond\n    ;; no doc-str or metadata map\n    (vector? doc-str) (let [args* doc-str\n                            body* (into [meta-map] args&body)]\n                        `(defnc ~n nil {} ~args* ~@body*))\n    ;; metadata map, but no doc-str\n    (map? doc-str) (let [meta-map* doc-str\n                         args* meta-map\n                         body* args&body]\n                     `(defnc ~n nil ~meta-map* ~args* ~@body*))\n    ;; doc-str, but no metadata map\n    (vector? meta-map) (let [args* meta-map\n                             body* args&body]\n                         `(defnc ~n ~doc-str {} ~args* ~@body*))\n    :else (peanut\n            n\n            `(fn ~args ~@body)\n            (merge-meta-maps\n              meta-map\n              body\n              {:def? true}\n              (if doc-str {:doc doc-str})))))\n\n(defmacro fnc\n  \"Returns an fn form.\n   The returned function body will be wrapped in a let-block which will\n   conditionally rebind the function args to values of re-frame subscriptions.\"\n  [& [opts args & body]]\n  (if (vector? opts)\n    (let [body* (into [args] body)\n          args* opts]\n      `(fnc {} ~args* ~@body*))\n    (peanut nil `(fn ~args ~@body) (merge-meta-maps opts body {:def? false}))))","(ns peanuts.cards.ex-c4d3\n  (:require-macros [peanuts.core :as pn]))\n\n(pn/defnc compliment [n]\n  [:p (str n \" is an interesting name!\")])\n\n(pn/defnc greeting [n]\n  [:<>\n   [:p (str \"Hello, \" n \"!\")]\n   [compliment n]])\n\n[:div\n ;; Here [:name] will retain its original value only in the root peanuts component\n ;; You can also use the shorter :rl1 keyword instead of :redlist1\n [greeting ^:redlist1 [:name]]]","(ns peanuts.cards.ex-e6c7)\n\n(defn greeting* [n]\n  [:p (str \"Hello, \" n \"!\")])\n\n(defn greeting []\n  (let [n @(re-frame.core/subscribe [:name])]\n    [greeting* n]))\n\n[greeting]"]);
peanuts.compile.namespace_declaration = "(ns cljs.user (:require-macros [peanuts.core :refer [defnc fnc]]))\n";
/**
 * A namespace loader that looks in the dependencies bundle for required namespaces.
 */
peanuts.compile.loader = (function peanuts$compile$loader(p__30299,callback){
var map__30300 = p__30299;
var map__30300__$1 = cljs.core.__destructure_map.call(null,map__30300);
var name = cljs.core.get.call(null,map__30300__$1,new cljs.core.Keyword(null,"name","name",1843675177));
var str_name = name.str;
var source = peanuts.compile.dependencies.call(null,str_name);
if(cljs.core.truth_(source)){
console.log(["Loading ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(str_name)].join(''));
} else {
console.log(["Unable to load ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(str_name)].join(''));
}

return callback.call(null,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"lang","lang",-1819677104),new cljs.core.Keyword(null,"clj","clj",-660495428),new cljs.core.Keyword(null,"source","source",-433931539),cljs.core.str.cljs$core$IFn$_invoke$arity$1(source)], null));
});
/**
 * A compiler state, which is shared across compilations.
 */
peanuts.compile.state = cljs.js.empty_state.call(null);
peanuts.compile.evaluate = (function peanuts$compile$evaluate(s,cb){
return cljs.js.eval_str.call(null,peanuts.compile.state,s,null,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,"eval","eval",-1103567905),cljs.js.js_eval,new cljs.core.Keyword(null,"load","load",-1318641184),peanuts.compile.loader], null),cb);
});
